---
title: 'Exemples'
description: "Cas d'usage complets et bonnes pratiques"
---

## Package minimal

Le plus simple : une seule fonction.

<CodeGroup>

```yaml mecapy.yml
name: simple-calc
description: Calculateur simple

functions:
  add:
    handler: calculator:add
```

```python calculator.py
def add(x: float, y: float) -> float:
    """Additionne deux nombres."""
    return x + y
```

</CodeGroup>

<Note>
  Pas besoin de `requirements.txt` si vous n'avez pas de dÃ©pendances externes.
</Note>

## Package avec validation

Fonctions avec contraintes Pydantic.

<CodeGroup>

```yaml mecapy.yml
name: calculs-mecaniques
description: Calculs avec validation

functions:
  calcul-contrainte:
    handler: calculs:calculer_contrainte
    description: Calcul de contrainte avec validation

  analyser-designation:
    handler: calculs:analyser_designation
    description: Analyse une dÃ©signation de vis
```

```python calculs.py
from typing import Annotated, TypedDict, Literal
from pydantic import Field

def calculer_contrainte(
    force: Annotated[float, Field(
        description="Force en Newton",
        ge=0,
        le=500000,
        examples=[1000, 5000, 10000]
    )],
    diametre: Annotated[float, Field(
        description="DiamÃ¨tre en mm",
        ge=3,
        le=100,
        examples=[6, 8, 10, 12, 16]
    )]
) -> dict:
    """
    Calcule la contrainte de traction.

    Parameters
    ----------
    force : float
        Force de traction appliquÃ©e
    diametre : float
        DiamÃ¨tre nominal de la vis

    Returns
    -------
    dict
        Contrainte et aire
    """
    aire = 3.14 * (diametre / 2) ** 2
    contrainte = force / aire
    return {
        "contrainte": round(contrainte, 2),
        "aire": round(aire, 2),
        "unite": "MPa"
    }

def analyser_designation(
    designation: Annotated[str, Field(
        pattern="^M[0-9]{1,2}$",
        examples=["M6", "M8", "M12", "M16"]
    )]
) -> dict:
    """
    Analyse une dÃ©signation de vis mÃ©trique.

    Parameters
    ----------
    designation : str
        DÃ©signation (M6, M8, M12, etc.)

    Returns
    -------
    dict
        Informations sur la vis
    """
    diametre = int(designation[1:])
    return {
        "diametre": diametre,
        "type": "metrique",
        "designation": designation
    }
```

</CodeGroup>

## Package POO avec mÃ©thodes

Utilisation de classes avec Ã©tat.

<CodeGroup>

```yaml mecapy.yml
name: mecapy-vis
description: Calculs d'assemblages boulonnÃ©s

functions:
  # MÃ©thode d'instance
  calcul-traction:
    handler: vis.Vis:calculer_contrainte_traction
    description: Contrainte de traction
    init: [diametre, materiau]

  calcul-cisaillement:
    handler: vis.Vis:calculer_cisaillement
    description: Contrainte de cisaillement
    init: [diametre, materiau]

  # Classmethod
  creation-vis:
    handler: vis.Vis:depuis_designation
    description: CrÃ©e une vis depuis dÃ©signation

  # MÃ©thode d'une autre classe
  calcul-precharge:
    handler: vis.BoulonHR:calculer_precharge
    description: PrÃ©charge pour boulon HR
    init: [diametre, classe]

runtime:
  python: "3.12"
  timeout: 300
```

```python vis.py
from typing import TypedDict, Literal, Annotated
from pydantic import Field

class ResultatContrainte(TypedDict):
    """RÃ©sultat d'un calcul de contrainte."""
    contrainte: float
    statut: Literal["OK", "LIMITE", "RUPTURE"]
    coefficient_securite: float
    unite: str

class Vis:
    """Classe reprÃ©sentant une vis."""

    def __init__(self, diametre: float, materiau: str):
        """
        Initialise une vis.

        Parameters
        ----------
        diametre : float
            DiamÃ¨tre nominal en mm
        materiau : str
            MatÃ©riau (acier, inox)
        """
        self.diametre = diametre
        self.materiau = materiau
        self.aire_section = 3.14 * (diametre / 2) ** 2

        # RÃ©sistance selon matÃ©riau
        if materiau == "acier":
            self.resistance = 400  # MPa
        elif materiau == "inox":
            self.resistance = 500  # MPa
        else:
            self.resistance = 300  # MPa

    def calculer_contrainte_traction(
        self,
        force: Annotated[float, Field(ge=0, le=500000)]
    ) -> ResultatContrainte:
        """
        Calcule la contrainte de traction.

        Parameters
        ----------
        force : float
            Force de traction en N

        Returns
        -------
        ResultatContrainte
            RÃ©sultat avec statut
        """
        contrainte = force / self.aire_section
        coef = self.resistance / contrainte

        if coef >= 2:
            statut = "OK"
        elif coef >= 1.5:
            statut = "LIMITE"
        else:
            statut = "RUPTURE"

        return {
            "contrainte": round(contrainte, 2),
            "statut": statut,
            "coefficient_securite": round(coef, 2),
            "unite": "MPa"
        }

    def calculer_cisaillement(
        self,
        force: Annotated[float, Field(ge=0, le=500000)]
    ) -> dict:
        """Calcule la contrainte de cisaillement."""
        tau = force / self.aire_section
        return {
            "cisaillement": round(tau, 2),
            "unite": "MPa"
        }

    @classmethod
    def depuis_designation(cls, designation: str) -> dict:
        """
        CrÃ©e une vis depuis sa dÃ©signation.

        Parameters
        ----------
        designation : str
            DÃ©signation (M6, M8, M12, etc.)

        Returns
        -------
        dict
            Informations de la vis crÃ©Ã©e
        """
        diametre = int(designation[1:])
        vis = cls(diametre, "acier")
        return {
            "diametre": vis.diametre,
            "materiau": vis.materiau,
            "aire_section": round(vis.aire_section, 2),
            "resistance": vis.resistance
        }

class BoulonHR:
    """Boulon haute rÃ©sistance."""

    def __init__(
        self,
        diametre: float,
        classe: Literal["8.8", "10.9", "12.9"]
    ):
        """
        Initialise un boulon HR.

        Parameters
        ----------
        diametre : float
            DiamÃ¨tre en mm
        classe : str
            Classe de rÃ©sistance
        """
        self.diametre = diametre
        self.classe = classe

        # RÃ©sistance selon classe
        resistances = {
            "8.8": 640,
            "10.9": 900,
            "12.9": 1080
        }
        self.resistance = resistances[classe]

    def calculer_precharge(self) -> dict:
        """
        Calcule la prÃ©charge recommandÃ©e.

        Returns
        -------
        dict
            PrÃ©charge et couple de serrage
        """
        aire = 3.14 * (self.diametre / 2) ** 2
        precharge = 0.7 * self.resistance * aire
        couple = 0.2 * precharge * self.diametre

        return {
            "precharge": round(precharge, 2),
            "couple_serrage": round(couple, 2),
            "classe": self.classe,
            "unite_precharge": "N",
            "unite_couple": "N.mm"
        }
```

</CodeGroup>

<Tip>
  Utilisez les **classmethods** pour crÃ©er des instances avec diffÃ©rentes configurations (factory pattern).
</Tip>

## Package avec runtime personnalisÃ©

DiffÃ©rentes configurations par fonction.

<CodeGroup>

```yaml mecapy.yml
name: advanced-package
description: Package avec runtime custom

functions:
  # Fonction rapide - peu de ressources
  quick-calc:
    handler: tasks:quick_calculation
    description: Calcul rapide
    runtime:
      timeout: 30
      memory: 512

  # Fonction lourde - beaucoup de ressources
  heavy-calc:
    handler: tasks:heavy_calculation
    description: Calcul intensif
    runtime:
      timeout: 900
      memory: 8192

  # Fonction normale - utilise les defaults
  normal-calc:
    handler: tasks:normal_calculation
    description: Calcul standard

# Defaults pour toutes les fonctions
runtime:
  python: "3.12"
  timeout: 300
  memory: 2048

tests:
  framework: pytest
  min_coverage: 80
```

```python tasks.py
import time
from typing import List

def quick_calculation(numbers: List[float]) -> float:
    """Calcul rapide - moyenne simple."""
    return sum(numbers) / len(numbers)

def heavy_calculation(data: List[float]) -> dict:
    """
    Calcul intensif - traitement complexe.

    Simule un calcul qui prend du temps et de la mÃ©moire.
    """
    # Simulation calcul lourd
    results = []
    for _ in range(1000):
        results.extend([x**2 for x in data])

    return {
        "count": len(results),
        "sum": sum(results),
        "avg": sum(results) / len(results)
    }

def normal_calculation(x: float, y: float) -> float:
    """Calcul standard."""
    return (x + y) / 2
```

</CodeGroup>

## Package avec tests

Incluez des tests pytest.

<CodeGroup>

```yaml mecapy.yml
name: tested-package
description: Package avec tests validÃ©s

functions:
  calculate:
    handler: calculator:calculate

tests:
  framework: pytest
  min_coverage: 80
  command: "pytest tests/ -v"
```

```python calculator.py
from typing import Literal

def calculate(
    operation: Literal["add", "sub", "mul", "div"],
    x: float,
    y: float
) -> float:
    """
    Effectue une opÃ©ration mathÃ©matique.

    Parameters
    ----------
    operation : str
        OpÃ©ration (add, sub, mul, div)
    x : float
        Premier nombre
    y : float
        Second nombre

    Returns
    -------
    float
        RÃ©sultat de l'opÃ©ration

    Raises
    ------
    ValueError
        Si l'opÃ©ration est invalide
    ZeroDivisionError
        Si division par zÃ©ro
    """
    if operation == "add":
        return x + y
    elif operation == "sub":
        return x - y
    elif operation == "mul":
        return x * y
    elif operation == "div":
        if y == 0:
            raise ZeroDivisionError("Division par zÃ©ro")
        return x / y
    else:
        raise ValueError(f"OpÃ©ration invalide: {operation}")
```

```python tests/test_calculator.py
import pytest
from calculator import calculate

def test_addition():
    assert calculate("add", 2, 3) == 5

def test_soustraction():
    assert calculate("sub", 5, 3) == 2

def test_multiplication():
    assert calculate("mul", 2, 3) == 6

def test_division():
    assert calculate("div", 6, 2) == 3

def test_division_par_zero():
    with pytest.raises(ZeroDivisionError):
        calculate("div", 5, 0)

def test_operation_invalide():
    with pytest.raises(ValueError):
        calculate("invalid", 1, 2)
```

```txt requirements.txt
pytest>=7.0.0
```

</CodeGroup>

<Note>
  MecaPy exÃ©cute vos tests automatiquement lors du dÃ©ploiement et refuse le dÃ©ploiement si les tests Ã©chouent.
</Note>

## Structure de projet complÃ¨te

```
mon-package/
â”œâ”€â”€ mecapy.yml              # âœ… Manifest Ã  la racine
â”œâ”€â”€ requirements.txt        # âœ… DÃ©pendances
â”œâ”€â”€ README.md              # âœ… Documentation
â”œâ”€â”€ mon_package/           # ğŸ“ Code source
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ calculs.py
â”‚   â”œâ”€â”€ vis.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ tests/                 # ğŸ“ Tests
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_calculs.py
â”‚   â””â”€â”€ test_vis.py
â””â”€â”€ .gitignore            # âœ… Git ignore
```

## Bonnes pratiques

<CardGroup cols={2}>
  <Card title="Type hints partout" icon="code">
    Sur tous les paramÃ¨tres et retours de fonctions
  </Card>
  <Card title="Pydantic Field pour validation" icon="shield-check">
    Utilisez `ge`, `le`, `pattern` pour les contraintes
  </Card>
  <Card title="TypedDict pour retours" icon="brackets-curly">
    Retours structurÃ©s avec types explicites
  </Card>
  <Card title="Docstrings NumPy" icon="file-lines">
    Format NumPy pour descriptions automatiques
  </Card>
  <Card title="Tests pytest" icon="vial">
    Au moins 80% de couverture
  </Card>
  <Card title="Nommage cohÃ©rent" icon="text">
    kebab-case pour packages et fonctions
  </Card>
</CardGroup>

## Erreurs courantes Ã  Ã©viter

<AccordionGroup>
  <Accordion title="Pas de type hints" icon="triangle-exclamation">
    **âŒ Mauvais** :
    ```python
    def calculate(x, y):  # Pas de types
        return x + y
    ```

    **âœ… Bon** :
    ```python
    def calculate(x: float, y: float) -> float:
        return x + y
    ```
  </Accordion>

  <Accordion title="MÃ©thode sans init" icon="triangle-exclamation">
    **âŒ Mauvais** :
    ```yaml
    handler: vis.Vis:calculer
    # Manque init !
    ```

    **âœ… Bon** :
    ```yaml
    handler: vis.Vis:calculer
    init: [diametre, materiau]
    ```
  </Accordion>

  <Accordion title="Validation manquante" icon="triangle-exclamation">
    **âŒ Mauvais** :
    ```python
    def calc(force: float):  # Pas de contraintes
        return force / 100
    ```

    **âœ… Bon** :
    ```python
    def calc(
        force: Annotated[float, Field(ge=0, le=500000)]
    ):
        return force / 100
    ```
  </Accordion>

  <Accordion title="Retour dict non typÃ©" icon="triangle-exclamation">
    **âŒ Mauvais** :
    ```python
    def analyze() -> dict:  # dict gÃ©nÃ©rique
        return {"result": 42}
    ```

    **âœ… Bon** :
    ```python
    class Result(TypedDict):
        result: int

    def analyze() -> Result:
        return {"result": 42}
    ```
  </Accordion>
</AccordionGroup>

## Prochaines Ã©tapes

<CardGroup cols={2}>
  <Card
    title="DÃ©ployer votre package"
    icon="rocket"
    href="/quickstart"
  >
    Guide de dÃ©ploiement Ã©tape par Ã©tape
  </Card>
  <Card
    title="API Reference"
    icon="code"
    href="/api-reference/introduction"
  >
    Documentation complÃ¨te de l'API
  </Card>
</CardGroup>
